<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Title</title>
	<script src="1px.js.new/1px.js"></script>
</head>
<body>

<h1>{{ title }}</h1>


<script>
const {Observable} = require("observable");
const {tokenize, watch$$} = require("parse");

const {combine, of} = Observable;
const {map, tap} = Observable.operators;


const evaluate$$ = (function() {

	const $evaluateRules = {};

	const evaluate = (token) => {
		console.log(token.id, token.length, token);
		return $evaluateRules[token.id][token.length].apply(token, token);
	};

	function evaluateRule(id, callback) {
		$evaluateRules[id] = $evaluateRules[id] || Object.create(null);
		$evaluateRules[id][callback.length] = callback;
	}

	evaluateRule("(end)", () => of(undefined));

	evaluateRule("(literal)", function() { return of(this.value) });

	/// @TODO:///
	evaluateRule("this", function() {
		// return this.thisObj;
	});

	/// [1,2,3]
	evaluateRule("[", (a) => combine(...a.pipe(map(evaluate))));

	/// {foo: 123, bsr: 'abc'} @TODO:
	evaluateRule("{", (a) => {

		console.log(a);

		// return combine(...a.pipe(map(evaluate)).pipe(map(o);


		return of(a.reduce((object, o) => {
			object[o.key] = evaluate(o);
			return object;
		}, {}));
	});


	const unary = (callback) => (a) => evaluate(a).pipe(map(callback));
	const binary = (callback) => (a, b) => combine(evaluate(a), evaluate(b)).pipe(map(callback));

	evaluateRule("+", unary(a => +a));
	evaluateRule("-", unary(a => -a));
	evaluateRule("!", unary(a => !a));

	evaluateRule("+", binary(([a, b]) => a + b));
	evaluateRule("-", binary(([a, b]) => a - b));
	evaluateRule("*", binary(([a, b]) => a * b));
	evaluateRule("/", binary(([a, b]) => a / b));
	evaluateRule("%", binary(([a, b]) => a % b));

	evaluateRule("&&", binary(([a, b]) => a && b));
	evaluateRule("||", binary(([a, b]) => a || b));
	evaluateRule("===", binary(([a, b]) => a === b));
	evaluateRule("!==", binary(([a, b]) => a !== b));
	evaluateRule("==", binary(([a, b]) => a == b));
	evaluateRule("!=", binary(([a, b]) => a != b));
	evaluateRule("<", binary(([a, b]) => a < b));
	evaluateRule("<=", binary(([a, b]) => a <= b));
	evaluateRule(">", binary(([a, b]) => a > b));
	evaluateRule(">=", binary(([a, b]) => a >= b));
	evaluateRule(";", binary(([a, b]) => b));

	evaluateRule("?", (a, b, c) => evaluate(a).switchMap(bool => bool ? evaluate(b) : evaluate(c)));


	/// foo
	evaluateRule("(name)", function() {

		let thisObj = window;

		let a = thisObj[this.value];

		// @TODO:...
		this.object = thisObj;


		return Observable.castAsync(a);
	});


	/// foo.bar
	evaluateRule(".", function(a, b) {
		return evaluate(a).pipe(
			tap(object => {
				this.object = object;
				this.prop = b.value;
			}),

			map(object => object && object[b.value])
		);
	});

	/// foo[bar]
	evaluateRule("[", function(a, b) {
		return combine(evaluate(a), evaluate(b)).pipe(
			tap(([object, prop]) => {
				this.object = object;
				this.prop = prop;
			}),

			map(([object, prop]) => object && object[prop])
		);
	});

	/// foo(bar, ...baz)
	evaluateRule("(", function(a, b) {
		return combine(evaluate(a), combine(...b.map(evaluate))).pipe(
			map(([fn, args]) => fn.apply(a.object, args))
		);
	});


	// evaluateRule("=");
	// evaluateRule("|");
	// evaluateRule("=>");
	// evaluateRule("as");
	// evaluateRule("if");
	// evaluateRule("let");

	return evaluate;

}());


window.a = Observable.interval(1000).take(5);
window.b = watch$$(window, "b");
window.c = ["A", "B", "C", "D", "E"];

window.d = {
	x: 100,

	test: function() {
		return "xxxxx" + this.x;
	},
};


window.test = x => x * 10;


let root = tokenize("a + d.test()");
console.log(root);


let s = evaluate$$(root);


/// @TODO:... this + locals만 pipe해서 Parse Tree + Observable은 재사용하는 방식을 고민할것!!!!!!!!!!

s.subscribe(console.log);


class Context {
	constructor(scope) {
		this.thisObj = scope;

		const f = (...args) => evaluate$$(tokenize(String.raw(...args)));
		Object.setPrototypeOf(f, this);
		return f;
	}
}


const $ = new Context(window);


const {traverseDOM} = require();


traverseDOM(document.body, (node) => {

	switch (node.nodeType) {
		case Node.ELEMENT_NODE:
			if (node.tagName === "SCRIPT") return false;
			console.log(node);
			return;

		case Node.TEXT_NODE:
			console.log(node);
	}
})

</script>
</body>
</html>
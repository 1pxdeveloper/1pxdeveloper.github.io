<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Title</title>
	<script src="1px.js.new/1px.js"></script>
</head>
<body>

<h1>{{ title }}</h1>
<h2>this is a: {{ a }}</h2>
<h2 [style.color]="a">this is a+ "xyz": {{ a + "xyz" }}</h2>
<h2 [style.color]="color">this is a * 10: {{ a * 10 }}</h2>
<h2>this is a > 2 ? "2a" : "3a": {{a }} {{ a > 2 ? "2a" : "3a" }}</h2>
<!--<h2>this {{ d.test(a) }} {{ d.x }}</h2>-->
<h3>{{ [1,2,3] }}</h3>
<h3>{{ [1,2,3].length }}</h3>
<h3>{{ [1,2,3].join('|') }}</h3>


<ui>
	<li *foreach="rows as row"></li>
</ui>

<button (click)="click()">click</button>

<script>
const {Observable} = require("observable");
const {tokenize} = require("parse");
const {watch$$} = require("parse");

const {combine, of} = Observable;

const evaluate$$ = (function() {

	const $evaluateRules = Object.create(null);

	const evaluate = (token) => {
		// console.log(token.id, token.length, token);
		return $evaluateRules[token.id][token.length].apply(token, token);
	};

	const evaluateRule = (id, callback) => {
		$evaluateRules[id] = $evaluateRules[id] || Object.create(null);
		$evaluateRules[id][callback.length] = callback;
	};

	evaluateRule("(end)", () => of(undefined));

	evaluateRule("(literal)", function() { return of(this.value) });

	evaluateRule("this", function() { return of(this.thisObj) });


	/// Operators
	const unary = (callback) => (a) => evaluate(a).map(callback);
	const binary = (callback) => (a, b) => combine(evaluate(a), evaluate(b)).map(callback);
	const params = (array) => combine(...array.map(evaluate));

	/// [1,2,3]
	evaluateRule("[", params);

	/// {foo: 123, bsr: 'abc'} @TODO:
	evaluateRule("{", (a) => {

		console.log(a);

		// return combine(...a.pipe(map(evaluate)).pipe(map(o);


		// return of(a.reduce((object, o) => {
		// 	object[o.key] = evaluate(o);
		// 	return object;
		// }, {}));
	});

	evaluateRule("+", unary(a => +a));
	evaluateRule("-", unary(a => -a));
	evaluateRule("!", unary(a => !a));

	evaluateRule("+", binary(([a, b]) => a + b));
	evaluateRule("-", binary(([a, b]) => a - b));
	evaluateRule("*", binary(([a, b]) => a * b));
	evaluateRule("/", binary(([a, b]) => a / b));
	evaluateRule("%", binary(([a, b]) => a % b));

	evaluateRule("&&", binary(([a, b]) => a && b));
	evaluateRule("||", binary(([a, b]) => a || b));
	evaluateRule("===", binary(([a, b]) => a === b));
	evaluateRule("!==", binary(([a, b]) => a !== b));
	evaluateRule("==", binary(([a, b]) => a == b));
	evaluateRule("!=", binary(([a, b]) => a != b));
	evaluateRule("<", binary(([a, b]) => a < b));
	evaluateRule("<=", binary(([a, b]) => a <= b));
	evaluateRule(">", binary(([a, b]) => a > b));
	evaluateRule(">=", binary(([a, b]) => a >= b));
	evaluateRule(";", binary(([a, b]) => b));

	evaluateRule("?", (a, b, c) => evaluate(a).switchMap(bool => bool ? evaluate(b) : evaluate(c)));


	/// foo
	evaluateRule("(name)", function() {

		const thisObj = this.thisObj;

		let a = watch$$(thisObj, this.value);

		// @TODO:...
		this.object = thisObj;
		this.prop = this.value;


		return a;
	});


	/// foo.bar
	evaluateRule(".", function(a, b) {
		return evaluate(a)
			.tap(object => {
				this.object = object;
				this.prop = b.value;

				console.log(object, b.value)
			})

			.mergeMap(object => watch$$(object, b.value));
	});

	/// foo[bar]
	evaluateRule("[", function(a, b) {
		return combine(evaluate(a), evaluate(b))
			.tap(([object, prop]) => {
				this.object = object;
				this.prop = prop;
			})

			.mergeMap(([object, prop]) => watch$$(object, prop));
	});

	/// foo(bar, ...baz)
	evaluateRule("(", function(a, b) {
		return combine(evaluate(a), params(b))
			.map(([func, args]) => {
				if (typeof func !== "function") return;
				return Function.prototype.apply.call(func, a.object, args);
			});
	});


	// evaluateRule("=");
	// evaluateRule("|");
	// evaluateRule("=>");
	// evaluateRule("as");
	// evaluateRule("if");
	// evaluateRule("let");

	// console.log("$evaluateRules", $evaluateRules);

	return evaluate;

}());


/// -----------------------------------------------------------------------
/// Context
/// -----------------------------------------------------------------------
function _makeString(strings) {
	return Object(strings) === strings ? String.raw.apply(String, arguments) : String(strings);
}

class Context {
	constructor(thisObj, locals) {
		this.thisObj = thisObj;
		this.locals = locals;

		const f = (...args) => {
			const root = tokenize(_makeString(...args));
			for (const token of root.tokens) {
				token.thisObj = thisObj;
			}
			return evaluate$$(root);
		};

		Object.setPrototypeOf(f, this);
		return f;
	}

	disconnect() {
		console.log("disconnect")
	}

	fork() {
		console.log("fork");
		return this;
	}

	fromEvent(el, type, useCapture = false) {
		return Observable.fromEvent(el, type, useCapture);
	}
}


/// -----------------------------------------------------------------------
/// Compile
/// -----------------------------------------------------------------------
const {traverseDOM} = require();


const $compile = (el) => (data) => {

	const context = new Context(data);
	let ret;

	traverseDOM(el, (node) => {
		switch (node.nodeType) {
			case Node.ELEMENT_NODE:
				console.group(node.nodeName, node);
				ret = _$compile_element_node(node, context);
				console.groupEnd();
				return ret;

			case Node.TEXT_NODE:
				// console.log(node);
				return _$compile_text_node(node, context);
		}
	});
};


/// -----------------------------------------------------------------------
/// Compile Element
/// -----------------------------------------------------------------------
function _$compile_element_node(el, context) {
	if (el.tagName === "SCRIPT") return false;
	if (el.tagName === "STYLE") return false;

	const attributes = Array.from(el.attributes);
	const to = el;


	const hasTemplateDirective = ["*foreach", "*if", "*else"].some(attrName => {
		const attr = el.getAttributeNode(attrName);
		if (!attr) return false;

		console.log(attr, attr.nodeName, attrName);


		$module.directive.require([attr.nodeName, function(directive) {


			console.log("directive!!!!!!!!!!!", directive);

			directive(context, el, attr.nodeValue, attr.nodeName)


		}]);
		return true;
	});

	if (hasTemplateDirective) {
		return false;
	}


	for (const attr of attributes) {

		// /// Custom Directives
		// /// @TODO: custom-directive 등록할때 아래처럼 syntax를 등록하는건 어떨까?
		// let customDefaultPrevent = false;
		// $module.directive.require([attr.nodeName, directive => {
		// 	if (typeof directive === "function") {
		// 		let ret = directive(context, el, attr.nodeValue);
		// 		customDefaultPrevent = ret === false;
		// 	}
		// }]);
		// if (customDefaultPrevent) continue;


		/// Basic Directives
		if (templateSyntax(context, to, attr, "(", _event, ")")) continue;
		if (templateSyntax(context, to, attr, "[attr.", _attr, "]")) continue;
		// if (templateSyntax(context, to, attr, "[visible.", _visible2, "]")) continue;
		if (templateSyntax(context, to, attr, "[visible", _visible, "]")) continue;
		if (templateSyntax(context, to, attr, "[class.", _class, "]")) continue;
		if (templateSyntax(context, to, attr, "[style.", _style, "]")) continue;
		// if (templateSyntax(context, to, attr, "[show.", _transition, "]")) continue;
		if (templateSyntax(context, to, attr, "[(", _twoway, ")]")) continue;
		if (templateSyntax(context, to, attr, "[", _prop, "]")) continue;
		// if (templateSyntax(context, to, attr, "$", _ref2, "")) continue;
		// if (templateSyntax(context, to, attr, "#", _ref, "")) continue;
		// if (templateSyntax(context, to, attr, ".", _call, ")")) continue;
	}
}

function templateSyntax(context, el, attr, start, callback, end) {
	const {nodeName, nodeValue} = attr;
	if (nodeName.startsWith(start) && nodeName.endsWith(end)) {
		callback(context, el, nodeValue, nodeName.slice(start.length, -end.length));
		// el.removeAttributeNode(attr); // @TODO: DEBUG mode
		return true;
	}
}

const rAF$ = (value) => new Observable(observer => _.rAF(() => {
	observer.next(value);
	observer.complete();
}));

const renderPipeLine = $ => $.distinctUntilChanged().switchMap(rAF$);


function _visible(context, el, script, name) {

}

function _attr(context, el, script, attr) {
	return context(script)
		.pipe(renderPipeLine)
		.tap(value => _.isStringLike(value) ? el.setAttribute(attr, value) : el.removeAttribute(attr))
		.subscribe()
}

function _class(context, el, script, name) {
	return context(script)
		.pipe(renderPipeLine)
		.tap(value => _.isStringLike(value) ? el.classList.add(name) : el.classList.remove(name))
		.subscribe()
}

function _style(context, el, script, name) {
	const [prop, unit = ""] = name.split(".", 2);

	return context(script)
		.pipe(renderPipeLine)
		.map(value => {
			switch (unit) {
				case "url":
					return "url('" + encodeURI(value) + "')";

				default:
					return value + unit;
			}
		})
		.tap(value => el.style[prop] = value)
		.trace("Style!")
		.subscribe();
}

function _twoway(context, el, script, name) {

}

function _prop(context, el, script, name) {
	return context(script)
	// .pipe(renderPipeLine) // @TODO: hasOwnProperty가 없는데 HTMLElement가 가지고 있는 경우에는 renderPipe를 통해야함. ex) id, src 등...
		.tap(value => el[name] = value)
		.subscribe()
}

Event.pipes = {
	prevent: $ => $.tap(e => e.preventDefault()),
	stop: $ => $.tap(e => e.stopPropagation()),
	capture: $ => $,
	self: ($, element) => $.filter(e => e.target === element),
	once: $ => $.take(1),
	shift: $ => $.filter(e => e.shiftKey),
	alt: $ => $.filter(e => e.altKey),
	ctrl: $ => $.filter(e => e.ctrlKey),
	meta: $ => $.filter(e => e.metaKey),
	cmd: $ => $.filter(e => e.ctrlKey || e.metaKey)
};

function _event(context, el, script, value) {

	let [type, ...options] = value.split(/\s*\|\s*/);
	const useCapture = options.includes("capture");

	/// @FIXME: Keyboard Event
	const keys = [];
	if (type.startsWith("keydown") || type.startsWith("keypress") || type.startsWith("keyup")) {
		[type, ...keys] = type.split(".");
	}

	/// Normal Event
	let event$ = context.fromEvent(el, type, useCapture);
	if (keys.length) {
		event$ = event$.filter(e => keys.includes(e.key.toLowerCase()))
	}

	/// Event Pipe
	options.forEach(pipe => {
		let handler = Event.pipes[pipe];
		if (!handler) throw new Error(pipe + " is not registered event pipe.");
		event$ = handler(event$, el);
	});

	/// Event Handler
	return event$
		.switchMap(event => context.fork({event, el})(script).take(1))
		.subscribe()
}


/// -----------------------------------------------------------------------
/// Text Node
/// -----------------------------------------------------------------------
function _$compile_text_node(node, context) {
	let index = node.nodeValue.indexOf("{{");

	while(index >= 0) {
		node = node.splitText(index);
		index = node.nodeValue.indexOf("}}");
		if (index === -1) return;

		let next = node.splitText(index + 2);
		let script = node.nodeValue.slice(2, -2);
		node.nodeValue = "";
		context(script).pipe(renderPipeLine).subscribe(_nodeValue.bind(null, node));

		node = next;
		index = node.nodeValue.indexOf("{{");
	}
}

function _nodeValue(node, value) {
	/// HTML Element
	if (node.__node__) {
		for (const n of node.__node__) n.remove();
		delete node.__node__;
	}

	if (value instanceof Node) {
		node.nodeValue = "";
		node.__node__ = Array.from(value.childNodes || [value]);
		node.before(value);
		return;
	}

	node.nodeValue = value === undefined ? "" : value;
}


/// -----------------------------------------------------------------------
/// Test
/// -----------------------------------------------------------------------


$module.factory("App", function() {


	return function App() {
		const colors = ["red", "blue", "orange", "black", "gray"];

		this.a = Observable.interval(1000).map(i => colors[i]).take(5);
		this.c = ["A", "B", "C", "D", "E"];

		this.d = {
			x: 100,

			test: function(abc) {
				return "xxxxx" + this.x + abc;
			}
		};

		this.test = x => x * 10;
		this.title = "Asdklfjasdlkfjaklsd";


		this.rows = colors;

		this.click = () => {
			this.title = Math.random().toString(32).slice(2);
		}
	}


});


$module.require(function(App) {


	console.log("App", App);


	$compile(document.body)(new App);
});


</script>
</body>
</html>
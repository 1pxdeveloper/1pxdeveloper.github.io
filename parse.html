<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Title</title>
</head>
<body>
<script>


/// Tokenize
function tokenize(script, callbackfn) {
	let tokens = [];

	script.replace(tokenize.re, function(a) {
		let len = arguments.length;
		for (let i = 1; i < len; i++) {
			let value = arguments[i];

			if (value !== undefined) {
				value = callbackfn(value, tokenize.lex[i - 1][0]);
				if (value !== undefined) {
					tokens.push(value);
				}
				return a;
			}
		}

		return a;
	});

	tokens.index = 0;
	return tokens;
}


/// Pratt top-down parser
let $token;
let $tokens;

function next(id) {
	if (id && $token && $token.id !== id) {
		throw SyntaxError("Unexpected token: " + $token.id);
	}

	let t = $token;
	$token = $tokens[$tokens.index++] || $symbol_table["(end)"];
	return t;
}

function expression(rbp) {
	rbp = rbp || 0;

	let t = next();

	let left = t.nud() || t;
	while ($token.lbp > rbp) {
		t = next();
		left = t.led(left) || t;
	}

	return left;
}

let $symbol_table = {};

let $symbol_prototype = {
	lbp: 0,
	nbp: 0,
	length: 0,
	global: null,
	local: null,

	nud() { throw SyntaxError(this.id + " is undefined token."); },

	led() { throw SyntaxError(this.id + " is missing pperator."); },

	push() {
		for (let token of arguments) {
			this[this.length++] = token;
		}
		return arguments[arguments.length - 1];
	},

	setObjectProp(object, prop) {
		this.object = object;
		this.prop = prop;
		this.watch(object, prop);
		return object && object[prop];
	},

	watch(object, prop) {}
};

function symbol(id) {
	let s = $symbol_table[id] = $symbol_table[id] || Object.create($symbol_prototype);
	s.id = id;
	return s;
}

function default_constant_nud() {
	this.id = "(literal)";
}

function default_prefix_nud() {
	this.push(expression(this.nbp));
}

function default_infix_led(left) {
	this.push(left, expression(this.lbp));
}

function default_infixr_led(left) {
	this.push(left, expression(this.lbp - 1));
}

function constant(id, value) {
	let s = symbol(id);
	s.value = value;
	s.nud = default_constant_nud;
	return s;
}

function prefix(operator, nud) {
	symbol(operator).nud = nud || default_prefix_nud;
}

function infix(operator, led) {
	symbol(operator).led = led || default_infix_led;
}

function infixr(operator, led) {
	symbol(operator).led = led || default_infixr_led;
}


/////////// Combination
symbol(",");
symbol(":");
symbol(")");
symbol("]");

symbol("(end)");
symbol("(name)");
symbol("(literal)").nud = default_constant_nud;

constant("true", true);
constant("false", false);
constant("undefined", undefined);
constant("null", null);
constant("NaN", NaN);
constant("Math", Math);
constant("Date", Date);
constant("Boolean", Boolean);
constant("Number", Number);
constant("Array", Array);
constant("Object", Object);
constant("Function", Function);


parse.operator_precedence = [
	[1, "(", "[", "{"],
	[2, ".", "["],
	[2, "("],

	// [1, "!", "~", "+", "-", "typeof", "void", "delete"],
	[1, "!", "+", "-"],

	[2, "**", "*", "/", "%"],
	[2, "+", "-"],

	// [2, "<", "<=", ">", ">=", "in", "instanceof"],
	[2, "<", "<=", ">", ">=", "in"],
	[2, "===", "!==", "==", "!="],

	[2, "&&", "||"],
	[2, "?"],

	[2, "if"],

	[2, "="],

	[2, ";"],
];

parse.operator_precedence.forEach((precedence, index, A) => {
	let [num, ...operators] = precedence;
	let bp = num === 1 ? "nbp" : "lbp";
	let len = A.length;

	for (let operator of operators) {
		let s = symbol(operator);
		s[bp] = (len - index) * 10;
	}
});


/// define parse rule of operators
["!", "+", "-"].forEach(o => prefix(o));
["*", "/", "%", "+", "-", "<", "<=", ">", ">=", "in", "instanceof", "===", "!==", "==", "!=", "&&", "||", ";", "if"].forEach(o => infix(o));
["**", "="].forEach(o => infixr(o));

prefix("[", function() {
	let args = this.push([]);
	let index = 0;
	for (; ;) {
		if ($token.id === "]") break;
		if ($token.id === ",") {
			index++;
			args.length = index;
			next(",");
			continue;
		}
		args[index] = expression();
	}

	next("]");
});

prefix("{", function() {
	let args = this.push({});
	let key;

	for (; ;) {
		if ($token.id === "}") break;

		if ($token.id !== "(name)" && $token.id !== "(literal)") {
			throw SyntaxError("Unexpected token: " + $token.id);
		}
		key = next().value;

		/// @TODO:.. ex) {name, value}
		if ($token.id !== ":") {

		}

		next(":");
		args[key] = expression();

		if ($token.id === "}") break;
		next(",");
	}

	next("}");
});

infix(["."], function(left) {
	this.push(left);
	this.push(next("(name)"));
});

infix(["["], function(left) {
	this.push(left);
	this.push(expression());
	next("]");
});

infix(["?"], function(left) {
	this.push(left);
	this.push(expression());
	next(":");
	this.push(expression());
});

infix(["("], function(left) {
	let args = this.push(left, []);

	for (; ;) {
		if ($token.id === ")") break;
		args.push(expression());
		if ($token.id === ")") break;
		next(",");
	}

	next(")");
});


/// evaluate rules
/// @FIXME: 꼭 apply를 token으로 해야 될 필요가 있을까? 쓰는게 setObjectProp (watch용), this.global 은 공통인데?, literal 떄문에?? a를 만들면 되지 않을까? this.push(this.value)로...
function evaluate(token) {
	return evaluate.table[token.id][token.length].apply(token, token);
}

const modulo = (a, b) => (+a % (b = +b) + b) % b;

evaluate.rules = [
	["(end)", () => undefined],
	["(literal)", function() { return this.value}],

	["[", (a) => a.map(evaluate)],

	[";", (a, b) => void evaluate(a) || evaluate(b)],

	["typeof", (a) => typeof evaluate(a)],
	["+", (a) => +evaluate(a)],
	["-", (a) => -evaluate(a)],
	["!", (a) => !evaluate(a)],
	["[", (a) => a.map(evaluate)],
	["{", (a) => new Error('undefined')], /// @TODO: {name, mask, weapon}

	["instanceof", (a, b) => evaluate(a) instanceof evaluate(b)], /// @FIXME:? is?
	["+", (a, b) => evaluate(a) + evaluate(b)],
	["-", (a, b) => evaluate(a) - evaluate(b)],
	["*", (a, b) => evaluate(a) * evaluate(b)],
	["*", (a, b) => Math.pow(evaluate(a), evaluate(b))],
	["/", (a, b) => evaluate(a) / evaluate(b)],
	["%", (a, b) => evaluate(a) % evaluate(b)],
	["%%", (a, b) => modulo(evaluate(a), evaluate(b))],
	["in", (a, b) => Array.prototype.indexOf.call(evaluate(b), evaluate(a) >= 0)],

	["==", (a, b) => evaluate(a) == evaluate(b)],
	["!=", (a, b) => evaluate(a) != evaluate(b)],
	["===", (a, b) => evaluate(a) === evaluate(b)],
	["!==", (a, b) => evaluate(a) !== evaluate(b)],
	["<", (a, b) => evaluate(a) < evaluate(b)],
	["<=", (a, b) => evaluate(a) <= evaluate(b)],
	[">", (a, b) => evaluate(a) > evaluate(b)],
	[">=", (a, b) => evaluate(a) >= evaluate(b)],
	["||", (a, b) => evaluate(a) || evaluate(b)],
	["&&", (a, b) => evaluate(a) && evaluate(b)],

	["?", (a, b, c) => evaluate(a) ? evaluate(b) : evaluate(c)],

	["(name)", function(a) { return this.setObjectProp(this.global, a.value); }],
	[".", function(a, b) { return this.setObjectProp(evaluate(a), b.value); }],
	["[", function(a, b) { return this.setObjectProp(evaluate(a), evaluate(b)); }],

	["(", (a, b) => {
		let fn = evaluate(a);
		return fn.apply(a.object, b.map(evaluate));
	}],

	["if", function(a, b) { /* TODO */ }],
	["as", function(a, b) { /* TODO */ }],

	["=>", function(a, b) { /* TODO */ }], // array function

	["=", function(a, b) { /* TODO */ }], // ASSIGN
];


evaluate.table = evaluate.rules.reduce((table, def) => {
	let [id, fn] = def;
	let length = fn.length;
	table[id] = table[id] || {};
	table[id][length] = fn;
	return table;
}, Object.create(null));


/// Tokenizer
tokenize.lex = [
	["(name)", /([_$a-zA-Z가-힣][_$a-zA-Z0-9가-힣]*)/],
	["(number)", /((?:\d*\.\d+)|\d+)/],
	["(string)", /('[^']*'|"[^"]*"|`[^`]*`)/],
	["(operator)", /(===|!==|==|!=|<=|>=|=>|&&|%%|\|\||[-|+*/%!?:;.,<>=\[\]\(\){}])/],
	["(ws)", /(\s)/],
	["(unknown)", /./]
];
tokenize.re = new RegExp(tokenize.lex.map(r => r[1].source).join("|"), "g");


function createToken(value, type) {
	let token;

	switch (type) {
		case "(name)":
			token = Object.create($symbol_table[value] || $symbol_table["(name)"]);
			token.value = "value" in token ? token.value : value;
			return token;

		case "(number)":
			token = Object.create($symbol_table["(literal)"]);
			token.value = +value;
			return token;

		case "(string)":
			token = Object.create($symbol_table["(literal)"]);
			token.value = value.slice(1, -1);
			return token;

		case "(operator)":
			token = Object.create($symbol_table[value]);
			token.value = value;
			return token;
	}

	return token;
}

function parse(script) {
	$tokens = tokenize(script, createToken);
	next();
	let root = expression();
	next("(end)");

	return root;
}


/// Run
let script = "1 + 2 / 3 * 4 + 1 - 2";

script = "[,,1,2,3,4,6,,]";
// script = "Math.round(1.5)";

// script = "1 < 2 ? 5 : 3 < 2 ? 1 : 2";


let root = parse(script);

console.log(root);
console.log(evaluate(root));
console.log(eval(script));


</script>
</body>
</html>
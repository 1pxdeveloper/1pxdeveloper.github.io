<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Title</title>
	<script>window.exports = {}</script>
	<script src="1px.js.new/observable.js"></script>
</head>
<body>

<script>
"use strict";

const {ReplaySubject} = exports;


/// Util
const noop = () => {};

/// PIPE
const pipe = (...args) => (value) => args.reduce((f, g) => g(f), value);

const co = (...args) => (observable) => {


	return new Observable(observer => {

		observer.complete = noop;

		return observable.subscribe({
			next(value) {

				value = Observable.of(value);

				for (const arg of args) {
					value = value.pipe(arg, tap(v => observer.next(v)));
				}

				value.subscribe();
			},

			error() {

			},

			complete() {

			}
		});


		// let num_completed = 0;
		// let subject = new ReplaySubject();
		//
		// let o = Object.setPrototypeOf({
		// 	complete() {
		// 		num_completed++;
		// 		if (num_completed >= args.length) {
		// 			subject.complete();
		// 		}
		// 	}
		// }, subject);

		// observable.subscribe(console.warn);


		// for (const arg of args) {
		// 	subject.pipe(arg).subscribe(o);
		// }

		// window.subject = subject;

		// return subject;

		// return Observable.of("test");


	});

};


Observable.pipe = pipe;
Observable.prototype.pipe = function(...args) { return pipe(...args)(this) };
Observable.prototype.co = function(...args) { return co(...args)(this) };


/// ---------------------------------------------------------------------------
/// Observable: Creation
/// ---------------------------------------------------------------------------
const fromEvent = (el, type, useCapture = false) => new Observable(observer => {
	const handler = (event) => observer.next(event);
	el.addEventListener(type, handler, useCapture);
	return () => el.removeEventListener(type, handler, useCapture);
});


/// ---------------------------------------------------------------------------
/// Operators: lift
/// ---------------------------------------------------------------------------
const lift = (callback) => (observable) => new Observable(observer => {
	const s = observable.subscribe(Object.setPrototypeOf(callback(observer), observer));
	return () => {
		s.unsubscribe();
		typeof observer.finallize === "function" && observer.finallize();
	}
});

const $next = (callback) => lift(observer => ({next: callback(observer)}));
const $complete = (callback) => lift(observer => ({complete: callback(observer)}));


/// ---------------------------------------------------------------------------
/// Operators
/// ---------------------------------------------------------------------------
const map = (callback) => $next((observer, index = 0) => value => observer.next(callback(value, index++)));
const mapTo = (value) => $next((observer) => () => observer.next(value));

const filter = (callback) => $next((observer, index = 0) => value => callback(value, index++) && observer.next(value));

const take = (num) => lift((observer) => ({
	start() { if (num <= 0) observer.complete() },

	next(value) {
		observer.next(value);
		if (--num <= 0) observer.complete();
	}
}));

const tap = (onNext, onComplete = noop) => lift((observer) => ({
	next(value) {
		onNext(value);
		observer.next(value);
	},

	complete() {
		onComplete();
		observer.complete();
	}
}));

const scan = function(callback, initialValue) {
	const hasInitialValue = arguments.length > 1;

	return (observable) => new Observable((observer, currentValue = initialValue) => {

		const o1 = Object.setPrototypeOf({
			next(value) {
				currentValue = value;
				o1.next = o2.next;
			}
		}, observer);

		const o2 = Object.setPrototypeOf({
			next(value) {
				currentValue = callback(currentValue, value);
				observer.next(currentValue);
			}
		}, observer);

		return observable.subscribe(hasInitialValue ? o2 : o1);
	})
};


/// Map
const mergeMap = (callback) => lift(observer => {


});


const merge = (...observables) => new Observable(observer => {

	let o = Object.setPrototypeOf(observer, {
		complete() {}
	});

	let ss = observables.map(observable => observable.subscribe(o));

	return () => {
		for (const s of ss) {
			s.unsubscribe();
		}
	}
});


/// Share
const shareReplay = (num = Infinity) => (observable) => {

	let subscription, replay = [], observers = [];

	return new Observable(observer => {
		for (const value of replay) {
			observer.next(value);
		}

		if (subscription && subscription.closed) {
			observer.complete();
			return;
		}

		observers.push(observer);

		subscription = subscription || observable.subscribe({
			next(value) {
				replay.push(value);
				replay = replay.slice(-num);
				for (const observer of observers) observer.next(value);
			},

			error(error) {
				for (const observer of observers) observer.error(error);
			},

			complete() {
				for (const observer of observers) observer.complete();
			}
		});

		return () => {
			observers = observers.filter(_observer => _observer !== observer);
			if (observers.length === 0) {
				subscription.unsubscribe();
			}
		}
	});
};


/// Array like
const toArray = () => lift((observer, array = []) => ({
	next: (value) => {
		console.log(value);

		array.push(value);
	},
	complete: () => {
		observer.next(array);
		observer.complete();
	}
}));

const Range = (start, stop, step = 1) => new Observable(observer => {
	start = Math.floor(start);
	stop = Math.ceil(stop);

	while (start !== stop) {
		observer.next(start);
		start += step;
	}

	observer.complete();
});


/// List
const List = {};

List.pipe = pipe;

for (const method of Object.getOwnPropertyNames(Array.prototype)) {
	if (typeof Array.prototype[method] === "function") {
		List[method] = (...args) => map(array => array[method](...args));
	}
}

/// MUTATION_METHODS_OF_ARRAY:
for (const method of ["pop", "shift", "reverse", "splice", "sort"]) {
	List[method] = (...args) => map(array => array.slice()[method](...args))
}

/// MUTATION_METHODS_OF_ARRAY: -> return array
for (const method of ["push", "unshift"]) {
	List[method] = (...args) => map(array => {
		array = array.slice();
		array[method](...args);
		return array;
	})
}

List.of = (...items) => Observable.of(items);

List.from = (list) => Observable.of([...list]);

List.length = () => map(array => array.length);


const log = (...tag) => tap(v => console.log(...tag, JSON.stringify(v, null, 2)));


/// TODO MVC
const uuid = ((id = 0) => () => id++)();

const addTodo = ({title = "", completed = false}) => List.push({id: uuid(), title, completed});
const removeTodo = ({id}) => List.filter(todo => todo.id !== id);
const toggleAll = (completed) => List.map(todo => ({...todo, completed}));
const clearCompleted = () => List.filter(todo => !todo.completed);


// computed
const num_items_left = (todos) => todos.length - todos.filter(todo => todo.completed).length;


let todos$ = List.of();

// todos$ = todos$.pipe(
// 	addTodo({title: "hello"}),
// 	addTodo({title: "world"}),
// 	addTodo({title: "welcome"}),
// 	addTodo({title: "mimosa"}),
// 	removeTodo({id: 2}),
// 	shareReplay(1)
// );


// Observable.of(1, 2, 3, 4, 5).pipe(
// 	scan(((a, b) => a + b))
// ).subscribe(console.log);


todos$ = todos$.co(
	addTodo({title: "hello"}),
	addTodo({title: "world"}),
	addTodo({title: "welcome"}),
	addTodo({title: "mimosa"}),
	removeTodo({id: 2}),
	shareReplay(1)
);


todos$.subscribe(v => console.log(JSON.stringify(v, null, 2)));


const num_items_left$ = todos$.pipe(map(num_items_left));


num_items_left$.subscribe(console.log);


</script>

</body>
</html>